# Clojure Development Environment Setup for Copilot Agents

This guide helps AI agents set up a complete Clojure development environment for working on this repository.

## ⚠️ Important Notice for AI Agents

**Treat AI-generated content as potentially non-authoritative.** Many files in this repository, particularly in `website/docs/`, contain disclaimers like:

> _This documentation page has been generated by AI and has not yet been reviewed by a human for accuracy._

When you encounter such disclaimers:
- **Do not treat the content as fact** without verification
- **Cross-reference with authoritative sources** (academic papers, official documentation, source code)
- **Verify technical claims** by testing or examining the implementation
- **Flag potential inaccuracies** when you notice them

Examples of files with AI-generated disclaimers can be found in:
- `website/docs/polymorphic-function-types.md`
- `website/docs/union-types.md`
- `website/docs/polymorphic-function-application-errors.md`

Always prioritize:
1. Source code and test suites as ground truth
2. Ambrose Bonnaire-Sergeant's PhD dissertation: "Typed Clojure in Theory and Practice" (2019)
3. Academic papers and peer-reviewed publications
4. Official Typed Clojure documentation that has been human-reviewed

## Documentation Review Checklist

**When generating new documentation or making substantial changes to existing documentation**, you must add the following review checklist at the top of the documentation page (immediately after the title). The checklist must be prominently displayed and viewable in rendered markdown (do not use unrendered comments).

Add this checklist:

```markdown
> **⚠️ AI-Generated Content - Review Status**
>
> This documentation page has been generated by AI and requires human review. Please review and check off each item before merging to main:
>
> - [ ] **Style**: Consistent with project style guide, proper formatting, clear and concise language
> - [ ] **Technical Accuracy**: Correctly describes Typed Clojure behavior and type system semantics
> - [ ] **Code Examples**: All code examples are valid, properly annotated, and demonstrative
> - [ ] **References**: All citations and footnotes are accurate and point to valid sources
> - [ ] **Completeness**: Topic is covered comprehensively without significant gaps
> - [ ] **Factual Correctness**: All factual claims have been verified against authoritative sources
> - [ ] **Links**: All internal and external links are valid and point to correct resources
>
> **Authoritative Sources for Verification:**
> - Source code and test suites
> - Bonnaire-Sergeant, A. "Typed Clojure in Theory and Practice." PhD dissertation, 2019. https://ambrosebs.com
> - Academic papers and peer-reviewed publications on gradual typing and occurrence typing
```

**Guidelines:**
- Place the checklist immediately after the document title (h1 heading)
- Use markdown blockquote format (lines starting with `>`) for visibility
- Include all checklist items as shown above
- The checklist applies to documentation in `website/docs/` and other user-facing documentation
- Minor typo fixes or formatting changes do not require the checklist
- Substantial changes include: new content, major rewrites, significant additions to existing pages

## Prerequisites

- Linux environment (Ubuntu/Debian or similar)
- Internet access to:
  - `repo.clojars.org` (Clojure package repository)
  - `download.clojure.org` (Clojure installer downloads)
  - `github.com` (for Babashka installation)

## Installation Steps

### 1. Install Java

Java 8 or later is required (Java 21 is preferred).

Check if Java is already installed:
```bash
java -version
```

If not installed, install Java 21:
```bash
# For Ubuntu/Debian
sudo apt-get update
sudo apt-get install -y openjdk-21-jdk

# Verify installation
java -version
```

### 2. Install Babashka

Babashka is used for scripting in this repository. Install to a local directory:

```bash
# Download and install to /tmp/bb-install (or your preferred location)
curl -sLO https://raw.githubusercontent.com/babashka/babashka/master/install
chmod +x install
./install --dir /tmp/bb-install
rm install

# Add to PATH
export PATH="/tmp/bb-install:$PATH"

# Verify installation
bb --version
```

Alternative installation methods: https://github.com/babashka/babashka?tab=readme-ov-file#quickstart

### 3. Install Clojure CLI

Install the Clojure command-line tools:

```bash
# Download and install to /tmp/clojure-install (or your preferred location)
curl -L -O https://github.com/clojure/brew-install/releases/latest/download/linux-install.sh
chmod +x linux-install.sh
./linux-install.sh --prefix /tmp/clojure-install
rm linux-install.sh

# Add to PATH
export PATH="/tmp/clojure-install/bin:$PATH"

# Verify installation
clojure --version
```

Official installation guide: https://clojure.org/guides/install_clojure#_linux_instructions

### 4. Install clj-kondo (Optional but Recommended)

clj-kondo is a Clojure linter used by Typed Clojure's clj-kondo-hooks subproject. Install to a local directory:

```bash
# Download and install to /tmp/clj-kondo-install (or your preferred location)
curl -sLO https://raw.githubusercontent.com/clj-kondo/clj-kondo/master/script/install-clj-kondo
chmod +x install-clj-kondo
./install-clj-kondo --dir /tmp/clj-kondo-install
rm install-clj-kondo

# Add to PATH
export PATH="/tmp/clj-kondo-install:$PATH"

# Verify installation
clj-kondo --version
```

#### Installing Specific Versions of clj-kondo

To install a specific version of clj-kondo (useful for debugging compatibility issues):

```bash
# Set the desired version
CLJ_KONDO_VERSION="2024.09.27"

# Download and install specific version
curl -sLO "https://github.com/clj-kondo/clj-kondo/releases/download/v${CLJ_KONDO_VERSION}/clj-kondo-${CLJ_KONDO_VERSION}-linux-static-amd64.zip"
mkdir -p /tmp/clj-kondo-install
unzip -o "clj-kondo-${CLJ_KONDO_VERSION}-linux-static-amd64.zip" -d /tmp/clj-kondo-install
rm "clj-kondo-${CLJ_KONDO_VERSION}-linux-static-amd64.zip"

# Verify the version
/tmp/clj-kondo-install/clj-kondo --version
```

**Note:** The clj-kondo-hooks subproject uses the clj-kondo binary if available, otherwise falls back to the version specified in `example-projects/clj-kondo-hooks/deps.edn`. The binary is preferred for performance.

Alternative installation methods: https://github.com/clj-kondo/clj-kondo/blob/master/doc/install.md

## Repository-Specific Setup

### Understanding the Testing Infrastructure

This repository has several ways to run tests and code:

#### 1. Top-level Kaocha Test Runner

From the repository root:
```bash
./bin/kaocha
```

This runs all tests across all submodules. You can pass Kaocha arguments to run specific tests:
```bash
# Run tests with a specific focus
./bin/kaocha --focus typed-test.doc

# Run a specific test namespace
./bin/kaocha --focus typed-test.cljc.doc

# Other Kaocha options
./bin/kaocha --help
```

**Implementation note**: The `./bin/kaocha` script:
1. Regenerates selmer templates: `./script/regen-selmer.sh`
2. Generates dev project: `./script/gen-dev-project`
3. Runs: `clojure -M:nREPL:test:spec-skip-macros:kaocha -m typed.dev.kaocha-nrepl`

#### 2. Submodule Scripts

Each submodule (e.g., `typed/clj.checker/`) has its own scripts:

**Running tests:**
```bash
cd typed/clj.checker
./script/test
```

This executes: `clojure -M:test:kaocha:spec-skip-macros -m kaocha.runner`

**Starting a REPL:**
```bash
cd typed/clj.checker
./script/repl
```

This executes: `clj -M:test:nREPL:spec-skip-macros`

You can pass additional Clojure CLI arguments:
```bash
# Use a specific Clojure version
./script/repl -Sdeps '{:deps {org.clojure/clojure {:mvn/version "1.12.0"}}}'
```

#### 3. Raw Clojure Commands

Understanding the scripts helps you construct custom commands:

**Run code directly:**
```bash
clojure -M:test -e "(require 'typed.clojure) (typed.clojure/check-ns-clj 'some.namespace)"
```

**Start a REPL with test dependencies:**
```bash
clojure -M:test:nREPL
```

**Run specific tests with Kaocha:**
```bash
clojure -M:test:kaocha -m kaocha.runner --focus typed-test.doc
```

### Bidirectional Documentation Sync Scripts

This repository uses custom scripts for documentation testing:

#### Sync Documentation and Tests
```bash
# Generate test files from markdown code blocks
bb script/sync-doc-tests.clj website/docs/example.md

# Sync from test file back to markdown
bb script/sync-doc-tests.clj typed/clj.checker/test/typed_test/doc/example_abc123.clj
```

#### Capture Type Errors
```bash
# Capture type errors from a test file
bb script/capture-type-errors.clj typed/clj.checker/test/typed_test/doc/example_abc123.clj
```

#### Run Documentation Tests
```bash
# Run all documentation tests
bb script/run-doc-tests.clj
```

## Common Workflows

### Testing Code Changes

1. **Run all tests:**
   ```bash
   ./bin/kaocha
   ```

2. **Run tests for a specific submodule:**
   ```bash
   cd typed/clj.checker
   ./script/test
   ```

3. **Run specific test namespaces:**
   ```bash
   ./bin/kaocha --focus typed-test.doc
   ```

### Working with Documentation

1. **Add code block to markdown:**
   ```markdown
   ```clojure
   (+ 1 2)
   ```
   ```

2. **Generate test file:**
   ```bash
   bb script/sync-doc-tests.clj website/docs/your-file.md
   ```

3. **Capture type errors (if code should fail):**
   ```bash
   bb script/capture-type-errors.clj typed/clj.checker/test/typed_test/doc/your_file_abc123.clj
   ```

4. **Sync error back to markdown:**
   ```bash
   bb script/sync-doc-tests.clj website/docs/your-file.md
   ```

### Interactive Development

1. **Start a REPL:**
   ```bash
   cd typed/clj.checker
   ./script/repl
   ```

2. **Evaluate code in the REPL:**
   ```clojure
   (require '[typed.clojure :as t])
   (t/check-ns-clj 'some.namespace)
   ```

## Troubleshooting

### Dependencies Not Downloading

Ensure firewall allows access to:
- `repo.clojars.org`
- `download.clojure.org`

### Command Not Found

Make sure tools are in your PATH:
```bash
export PATH="/tmp/bb-install:/tmp/clojure-install/bin:$PATH"
```

### Test Failures

1. Check that all dependencies are downloaded (first run may be slow)
2. Review test output for specific failures
3. Check if tests pass in CI to rule out environment issues

### Debugging clj-kondo-hooks Failures

The clj-kondo-hooks subproject (`example-projects/clj-kondo-hooks/`) tests Typed Clojure's custom clj-kondo macro hooks to ensure compatibility with the latest clj-kondo release.

#### Running clj-kondo-hooks Tests

```bash
cd example-projects/clj-kondo-hooks
./script/test
```

This script:
1. Runs `./script/prep-lint` to copy configs
2. Runs `./script/lint` to lint the test file
3. Compares output with `output/expected-output`

#### Debugging Test Failures

If tests fail, it typically means clj-kondo changed its implementation causing incompatibility with Typed Clojure's hooks.

**IMPORTANT: The most likely scenarios are:**
1. **clj-kondo has introduced a bug** - The most valuable information is the exact release version (or commit) where the bug was introduced.
2. **clj-kondo changed its error message printing** - We simply need to update our expected printed messages in `output/expected-output`.

**Always assume one of these situations first. Only attempt intricate changes to macro hook definitions if explicitly prompted.**

#### AI Agent Workflow for Test Failures

When encountering a clj-kondo-hooks test failure, follow this workflow:

1. **Inspect the test failure output** - Compare `output/expected-output` with the actual output
   
2. **Make a judgement**:
   - **Printing change**: If error messages have same meaning but different formatting, update `output/expected-output`
   - **Bug suspected**: If seeing internal errors (like "No context found in: sci.ctx-store/*ctx*") or unexpected behavior

3. **If bug suspected**, use the automated binary search scripts:
   ```bash
   cd example-projects/clj-kondo-hooks
   ./script/bisect-release  # Fast: find bad release
   # This typically takes 5-10 tests
   ```
   
   If this used relatively few resources (time), continue to find the exact commit:
   ```bash
   ./script/bisect-commit [GOOD_COMMIT] [BAD_COMMIT]
   # Or use defaults from bisect-release output
   ```

4. **Inspect the problematic commit** to diagnose the problem:
   ```bash
   cd /tmp/clj-kondo-repo
   git log -1 --pretty=full COMMIT_SHA
   git show COMMIT_SHA
   ```
   
   Check surrounding PR/issue discussion for motivation.
   
   **AI Agent should analyze:**
   - **GOOD commit analysis**: Why does it succeed? What SCI context initialization is present?
   - **BAD commit analysis**: Why does it fail? What changed that breaks the macro hook?
   - Identify the specific lines/functions that are the culprit
   - Explain the behavior that the macro hook depends on
   - Example: "The GOOD commit initializes SCI context in function X before macro expansion. The BAD commit refactored this to use caching in function Y, which delays context initialization until after macros are expanded."

5. **Prepare a minimal reproduction** for clj-kondo maintainers:
   
   The ideal minimal reproduction consists of exactly 6 files:
   - `deps.edn` - Git dependencies with `:good-clj-kondo` and `:bad-clj-kondo` aliases
   - `test-good.sh` - Script to test with good commit
   - `test-bad.sh` - Script to test with bad commit  
   - `reproduction.clj` - Minimal code using the problematic macro hook (skip if the issue is loading hooks)
   - `.clj-kondo/reprod/reprod/hooks.clj` - The minimal macro hook that exhibits the bug
   - `.clj-kondo/reprod/reprod/config.edn` - Minimal config mapping the macro to the hook
   
   Each file should be as small as possible with no superfluous code.
   
   Create directory: `example-projects/clj-kondo-hooks/clj-kondo-bug-reproduction/`
   
   Only requires Java and Clojure CLI to run.

6. **Write a report** explaining:
   - The exact commit(s) where the bug was introduced
   - **Detailed commit analysis**:
     - Why the GOOD commit succeeds (what mechanism/initialization it has)
     - Why the BAD commit fails (what specific change broke the dependency)
     - The exact line(s) or function(s) that are the culprit
   - Root cause analysis (or most likely reason if inconclusive)
   - Steps to reproduce with the minimal test case
   - Expected vs actual behavior

#### Finding clj-kondo Release Versions

**DO NOT guess the names of clj-kondo releases** - they are irregularly spaced. Instead, check releases directly:

**Option 1: Clone the clj-kondo repo and check tags**
```bash
cd /tmp
git clone --depth 100 https://github.com/clj-kondo/clj-kondo.git clj-kondo-repo
cd clj-kondo-repo
git tag --sort=-version:refname | head -30
```

**Option 2: Browse releases on GitHub**
Visit https://github.com/clj-kondo/clj-kondo/releases

**Note:** Release names are dates (e.g., v2025.09.22 for September 22, 2025). Use this to refine your binary search.

#### Binary Search to Find the Problematic Version

**Step 1: Verify current clj-kondo version**
```bash
clj-kondo --version
```

**Step 2: Check the actual vs expected output**
```bash
cd example-projects/clj-kondo-hooks
./script/prep-lint
./script/lint > /tmp/actual-output
diff output/expected-output /tmp/actual-output
```

**Step 3: Get list of releases for binary search**
```bash
cd /tmp/clj-kondo-repo
git tag --sort=version:refname | grep "^v202" | tail -20
```

**Step 4: Test specific versions**
```bash
# Install a specific version to test
CLJ_KONDO_VERSION="2024.09.27"
curl -sLO "https://github.com/clj-kondo/clj-kondo/releases/download/v${CLJ_KONDO_VERSION}/clj-kondo-${CLJ_KONDO_VERSION}-linux-static-amd64.zip"
unzip -o "clj-kondo-${CLJ_KONDO_VERSION}-linux-static-amd64.zip" -d /tmp/clj-kondo-install
rm "clj-kondo-${CLJ_KONDO_VERSION}-linux-static-amd64.zip"

# Verify the version
clj-kondo --version

# Run the test
cd /path/to/example-projects/clj-kondo-hooks
./script/test
```

Use the exit status to determine if this version is "good" (exit 0) or "bad" (non-zero exit). Use release dates to refine the binary search.

**Automated Scripts:**

Two scripts are available to automate the binary search process:

1. **`./script/bisect-release`** - Binary search on clj-kondo releases
   - Faster because it uses pre-compiled binaries
   - Start here to find the first bad release
   - Usage: `cd example-projects/clj-kondo-hooks && ./script/bisect-release`

2. **`./script/bisect-commit`** - Binary search on commits between releases
   - More precise, finds the exact commit that introduced the bug
   - Use after finding the bad release with bisect-release
   - Usage: `./script/bisect-commit [GOOD_COMMIT] [BAD_COMMIT]`
   - If no arguments provided, uses known good/bad commits from v2025.06.05 to v2025.07.26

#### Modifying Macro Hooks (If Needed)

**IMPORTANT: Macro hooks in `typed/clj.runtime/resources/clj-kondo.exports/` are GENERATED files.**

Look for comments like:
```clojure
;; note: this file is copied into resources/clj-kondo.exports/org.typedclojure/typed.clj.runtime
;; via ./script/regen-kondo.sh
;; the canonical version is in the src folder
```

**To make changes to macro hooks:**

1. **Find the canonical source file** (mentioned in the comment at the top of the exported file)
2. **Edit the canonical source file** in `typed/clj.runtime/src/`
3. **Regenerate the exports** by running:
   ```bash
   ./script/regen-kondo.sh
   ```
4. **Test your changes** with the clj-kondo-hooks tests

**For short-term experimentation only**, you may directly manipulate the exported hooks, but **for final changes**, you MUST use the regeneration procedure above.

#### Finding the Exact Commit (After Finding the Bad Release)

Once you've identified the first bad release, it's even more valuable to find the exact commit that introduced the bug. This provides more precise information for reporting upstream.

**Why commit-level search is valuable:**
- Pinpoints the exact change that caused the issue
- Makes it easier for maintainers to understand and fix the bug
- Provides definitive proof of when the regression was introduced

**Strategy:**
1. First, perform binary search on releases (faster to test)
2. Once you find the first bad release, perform binary search on commits

**Using Git Dependencies for Commit-Level Testing**

Clojure's tools.deps supports git dependencies, which allows testing specific commits without compiling clj-kondo yourself.

**Git Dependency Format:**
```clojure
{:deps {clj-kondo/clj-kondo 
        {:git/url "https://github.com/clj-kondo/clj-kondo"
         :git/sha "COMMIT_SHA_HERE"}}}
```

**Steps to test a specific commit:**

1. **Find the commit range** between last GOOD release and first BAD release:
   ```bash
   cd /tmp/clj-kondo-repo
   git log --oneline v2025.06.05..v2025.07.26
   # Count commits: git log --oneline v2025.06.05..v2025.07.26 | wc -l
   # Get commit SHAs:
   GOOD_SHA=$(git rev-parse v2025.06.05)
   BAD_SHA=$(git rev-parse v2025.07.26)
   ```

2. **Update deps.edn** in `example-projects/clj-kondo-hooks/`:
   ```clojure
   {:deps {org.clojure/clojure {:mvn/version "1.12.0"}
           org.typedclojure/typed.clj.runtime {:local/root "../../typed/clj.runtime"}}
    :aliases {:clj-kondo
              {:replace-deps {clj-kondo/clj-kondo 
                              {:git/url "https://github.com/clj-kondo/clj-kondo"
                               :git/sha "COMMIT_SHA_TO_TEST"}}}
              ;; ... other aliases
              }}
   ```

3. **CRUCIAL: Ensure clj-kondo binary is NOT on PATH**
   
   The `script/clj-kondo` checks for a binary first. Remove it temporarily:
   ```bash
   # Rename the binary to prevent it from being used
   mv /tmp/clj-kondo-install/clj-kondo /tmp/clj-kondo-install/clj-kondo.backup
   ```

4. **Run the test:**
   ```bash
   cd example-projects/clj-kondo-hooks
   ./script/test
   ```
   
   This will use the git dependency from deps.edn instead of the binary.

5. **Perform binary search** on commits:
   - Start with midpoint commit between GOOD and BAD
   - Update deps.edn with that commit SHA
   - Run test to determine if GOOD or BAD
   - Repeat, narrowing down to the first bad commit

**Example automated script:**
See `example-projects/clj-kondo-hooks/script/bisect-commit` for a script that automates this process.

#### Analyzing the Root Cause

Once you find the version (or commit) where it broke:
1. Review the clj-kondo changelog for that version
2. Check if it's just a printing change (compare error messages)
3. If it's an internal clj-kondo error, report the bug
4. Only if explicitly directed, attempt to fix the macro hooks

#### Reporting Findings

- If it's a **printing change**: Update `output/expected-output` with the new error messages
- If it's a **clj-kondo bug**: Report via PR comment with exact version/commit and issue details
- If **hooks need fixing**: Update canonical source files, regenerate, and test

## Key Files to Study

For deeper understanding, examine these files:

- `./bin/kaocha` - Top-level test runner
- `./bin/typed` - Type checking wrapper
- `typed/clj.checker/script/test` - Submodule test runner
- `typed/clj.checker/script/repl` - Submodule REPL starter
- `script/sync-doc-tests.clj` - Documentation sync logic
- `script/capture-type-errors.clj` - Type error capture logic
- `script/run-doc-tests.clj` - Documentation test runner
- `deps.edn` - Project dependencies and aliases

## Complete Example Session

```bash
# 1. Setup environment (one-time)
export PATH="/tmp/bb-install:/tmp/clojure-install/bin:$PATH"

# 2. Navigate to repository
cd /path/to/private-core.typed

# 3. Run all tests
./bin/kaocha

# 4. Work on documentation
echo '```clojure
(+ 1 2)
```' > /tmp/test.md

# 5. Generate test file
bb script/sync-doc-tests.clj /tmp/test.md

# 6. Run doc tests
bb script/run-doc-tests.clj

# 7. Make changes to test file (edit with version bump)
# ... edit file ...

# 8. Sync back to markdown
bb script/sync-doc-tests.clj /tmp/test.md
```

## Additional Resources

- [Clojure CLI Guide](https://clojure.org/guides/deps_and_cli)
- [Babashka Documentation](https://book.babashka.org/)
- [Kaocha Test Runner](https://github.com/lambdaisland/kaocha)
- [Typed Clojure](https://github.com/typedclojure/typedclojure)
